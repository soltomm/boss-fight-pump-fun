<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Apex Gauntlet</title>
    <link rel="icon" type="image/png" href="apex_logo.png">
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@500;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            background: #0a0e27;
            color: white;
            overflow-x: hidden;
            min-height: 100vh;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(255, 0, 150, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(0, 240, 255, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 40% 20%, rgba(255, 215, 0, 0.1) 0%, transparent 50%);
            animation: gradientShift 15s ease infinite;
            z-index: 0;
        }

        @keyframes gradientShift {
            0%, 100% { opacity: 1; transform: scale(1) rotate(0deg); }
            50% { opacity: 0.8; transform: scale(1.1) rotate(5deg); }
        }

        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .particle {
            position: absolute;
            width: 3px;
            height: 3px;
            background: rgba(0, 240, 255, 0.8);
            border-radius: 50%;
            box-shadow: 0 0 10px currentColor;
            animation: float 20s infinite;
        }

        .particle:nth-child(odd) {
            background: rgba(255, 215, 0, 0.8);
            animation-duration: 15s;
        }

        .particle:nth-child(3n) {
            background: rgba(255, 0, 150, 0.8);
            animation-duration: 25s;
        }

        @keyframes float {
            0%, 100% { transform: translate(0, 0) rotate(0deg); opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { transform: translate(100px, -100vh) rotate(720deg); opacity: 0; }
        }

        .corner-logo {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid rgba(0, 240, 255, 0.5);
            box-shadow: 0 0 30px rgba(0, 240, 255, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.4s ease;
            animation: logoPulse 3s ease-in-out infinite;
        }

        @keyframes logoPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .corner-logo:hover {
            transform: scale(1.15) rotate(10deg);
            border-color: rgba(255, 215, 0, 0.8);
            box-shadow: 0 0 50px rgba(255, 215, 0, 1);
        }

        .small-logo {
            width: 90%;
            height: 90%;
            object-fit: contain;
        }

        .game-title {
            position: fixed;
            top: 28px;
            left: 115px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.8rem;
            font-weight: 900;
            color: #00f0ff;
            text-shadow: 
                0 0 20px #00f0ff,
                0 0 40px #00f0ff,
                0 0 60px rgba(0, 240, 255, 0.5);
            letter-spacing: 4px;
            z-index: 100;
            animation: titleGlow 3s ease-in-out infinite;
        }

        @keyframes titleGlow {
            0%, 100% { 
                text-shadow: 
                    0 0 20px #00f0ff,
                    0 0 40px #00f0ff,
                    0 0 60px rgba(0, 240, 255, 0.5);
            }
            50% { 
                text-shadow: 
                    0 0 30px #00f0ff,
                    0 0 60px #00f0ff,
                    0 0 90px rgba(0, 240, 255, 0.8),
                    0 0 120px rgba(255, 215, 0, 0.3);
            }
        }

        .container {
            display: flex;
            min-height: 100vh;
            padding: 20px;
            gap: 20px;
            position: relative;
            z-index: 2;
        }

        .left-panel, .right-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .left-panel { flex: 1; }
        .right-panel { width: 420px; }

        .card {
            background: rgba(10, 14, 39, 0.7);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 25px;
            border: 2px solid rgba(0, 240, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            transition: all 0.4s ease;
            position: relative;
            overflow: hidden;
        }

        .card:hover {
            border-color: rgba(0, 240, 255, 0.5);
            box-shadow: 0 12px 48px rgba(0, 240, 255, 0.3);
            transform: translateY(-5px);
        }

        .game-phase {
            text-align: center;
            font-size: 3rem;
            font-weight: 900;
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
            letter-spacing: 5px;
            animation: phaseGlow 2s ease-in-out infinite;
        }

        @keyframes phaseGlow {
            0%, 100% { filter: drop-shadow(0 0 20px currentColor); }
            50% { filter: drop-shadow(0 0 40px currentColor) brightness(1.3); }
        }

        .phase-betting { 
            color: #ffd700;
            text-shadow: 0 0 30px #ffd700;
        }

        .phase-fighting { 
            color: #ff0080;
            text-shadow: 0 0 30px #ff0080;
        }

        .phase-ended { 
            color: #00f0ff;
            text-shadow: 0 0 30px #00f0ff;
        }

        .phase-idle { 
            color: #a4b0be;
            text-shadow: 0 0 20px #a4b0be;
        }

        .timer {
            text-align: center;
            font-size: 2.5rem;
            margin-top: 20px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            color: #00f0ff;
            text-shadow: 0 0 20px #00f0ff;
            animation: timerPulse 1s ease-in-out infinite;
        }

        @keyframes timerPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .timer.warning {
            color: #ff0080;
            text-shadow: 0 0 20px #ff0080;
            animation: timerBlink 0.5s infinite;
        }

        @keyframes timerBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .boss-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 450px;
        }

        .boss-image-container {
            position: relative;
            width: 350px;
            height: 350px;
            margin: 30px 0;
            animation: bossFloat 4s ease-in-out infinite;
        }

        @keyframes bossFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-20px); }
        }

        .boss-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
            filter: drop-shadow(0 0 40px rgba(255, 0, 128, 0.8));
        }

        .boss-image.damaged {
            animation: bossShake 0.3s;
        }

        @keyframes bossShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-15px) rotate(-8deg); }
            75% { transform: translateX(15px) rotate(8deg); }
        }

        .boss-image.healed {
            animation: bossGlow 0.6s;
        }

        @keyframes bossGlow {
            0%, 100% { filter: drop-shadow(0 0 40px rgba(255, 0, 128, 0.8)); }
            50% { filter: drop-shadow(0 0 60px rgba(0, 240, 255, 1)) brightness(1.5); }
        }

        .boss-image.defeated {
            animation: bossDefeat 1.5s forwards;
        }

        @keyframes bossDefeat {
            0% { transform: scale(1) rotate(0); opacity: 1; }
            30% { transform: scale(1.2) rotate(10deg); }
            100% { transform: scale(0) rotate(-360deg); opacity: 0; }
        }

        .hit-effect, .heal-effect {
            position: absolute;
            font-size: 4rem;
            font-weight: 900;
            font-family: 'Orbitron', sans-serif;
            pointer-events: none;
            z-index: 10;
        }

        .hit-effect {
            color: #ff0080;
            text-shadow: 0 0 20px #ff0080;
            animation: hitExplosion 0.8s forwards;
        }

        @keyframes hitExplosion {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
            50% { transform: translate(-50%, -70%) scale(1.5); opacity: 1; }
            100% { transform: translate(-50%, -120%) scale(1); opacity: 0; }
        }

        .heal-effect {
            color: #00f0ff;
            text-shadow: 0 0 20px #00f0ff;
            animation: healRise 0.8s forwards;
        }

        @keyframes healRise {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
            50% { transform: translate(-50%, -30%) scale(1.3); opacity: 1; }
            100% { transform: translate(-50%, 0%) scale(1); opacity: 0; }
        }

        .boss-hp {
            width: 100%;
            max-width: 700px;
            margin-bottom: 25px;
        }

        .hp-bar {
            width: 100%;
            height: 60px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 30px;
            overflow: hidden;
            border: 3px solid rgba(0, 240, 255, 0.5);
            position: relative;
            box-shadow: 0 0 30px rgba(0, 240, 255, 0.5);
        }

        .hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0080 0%, #ff4757 25%, #ffa502 50%, #ffd700 75%, #00f0ff 100%);
            transition: width 0.6s ease;
            border-radius: 27px;
            box-shadow: 0 0 30px currentColor;
        }

        .hp-fill::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.6), transparent);
            animation: hpShimmer 2s infinite;
        }

        @keyframes hpShimmer {
            0% { left: -100%; }
            100% { left: 200%; }
        }

        .hp-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: 900;
            font-size: 1.8rem;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.8);
            z-index: 1;
        }

        .betting-section {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 20px;
            padding: 25px;
            margin-top: 20px;
            border: 2px solid rgba(0, 240, 255, 0.3);
        }

        .betting-section h3 {
            text-align: center;
            font-size: 1.8rem;
            font-family: 'Orbitron', sans-serif;
            color: #ffd700;
            text-shadow: 0 0 20px #ffd700;
            margin-bottom: 20px;
        }

        .betting-pools {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 25px;
        }

        .betting-pool {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            border: 3px solid;
            transition: all 0.4s ease;
            cursor: pointer;
        }

        .betting-pool.death {
            border-color: #ff0080;
            box-shadow: 0 0 30px rgba(255, 0, 128, 0.5);
            color: #ff0080;
        }

        .betting-pool.death:hover {
            transform: translateY(-10px) scale(1.05);
        }

        .betting-pool.survival {
            border-color: #00f0ff;
            box-shadow: 0 0 30px rgba(0, 240, 255, 0.5);
            color: #00f0ff;
        }

        .betting-pool.survival:hover {
            transform: translateY(-10px) scale(1.05);
        }

        .pool-title {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 15px;
            text-transform: uppercase;
            font-family: 'Orbitron', sans-serif;
        }

        .pool-amount {
            font-size: 2.5rem;
            color: #ffd700;
            margin-bottom: 10px;
            font-weight: 900;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 20px #ffd700;
        }

        .pool-bets {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .connect-wallet {
            width: 100%;
            background: linear-gradient(135deg, #00f0ff, #0080ff);
            color: white;
            border: none;
            padding: 18px;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 700;
            font-size: 1.2rem;
            font-family: 'Orbitron', sans-serif;
            transition: all 0.4s ease;
            margin-bottom: 15px;
            text-transform: uppercase;
            box-shadow: 0 5px 25px rgba(0, 240, 255, 0.5);
        }

        .connect-wallet:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 35px rgba(0, 240, 255, 0.8);
        }

        .wallet-connected {
            background: linear-gradient(135deg, #00f0ff, #2ed573);
        }

        .wallet-address {
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 10px;
        }

        .bet-form {
            display: none;
        }

        .bet-form.active {
            display: block;
        }

        .bet-input {
            width: 100%;
            padding: 15px;
            border: 2px solid rgba(0, 240, 255, 0.3);
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            font-size: 1.1rem;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        .bet-input:focus {
            outline: none;
            border-color: #00f0ff;
            box-shadow: 0 0 25px rgba(0, 240, 255, 0.5);
        }

        .bet-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .bet-buttons {
            display: flex;
            gap: 15px;
        }

        .bet-btn {
            flex: 1;
            padding: 18px;
            border: none;
            border-radius: 12px;
            font-size: 1.2rem;
            font-weight: 700;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            transition: all 0.4s ease;
            text-transform: uppercase;
            position: relative;
        }

        .bet-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .bet-btn.death {
            background: linear-gradient(135deg, #ff0080, #ff4757);
            color: white;
            box-shadow: 0 5px 25px rgba(255, 0, 128, 0.5);
        }

        .bet-btn.death:hover:not(:disabled) {
            transform: translateY(-5px);
            box-shadow: 0 8px 35px rgba(255, 0, 128, 0.8);
        }

        .bet-btn.survival {
            background: linear-gradient(135deg, #00f0ff, #2ed573);
            color: white;
            box-shadow: 0 5px 25px rgba(0, 240, 255, 0.5);
        }

        .bet-btn.survival:hover:not(:disabled) {
            transform: translateY(-5px);
            box-shadow: 0 8px 35px rgba(0, 240, 255, 0.8);
        }

        .leaderboard h3, .activity-feed h3 {
            text-align: center;
            font-size: 1.8rem;
            font-family: 'Orbitron', sans-serif;
            color: #ffd700;
            text-shadow: 0 0 20px #ffd700;
            margin-bottom: 20px;
        }

        .top-player {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            margin-bottom: 12px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 12px;
            border-left: 5px solid #ffd700;
            transition: all 0.3s ease;
        }

        .top-player:hover {
            background: rgba(255, 215, 0, 0.1);
            transform: translateX(10px);
        }

        .player-name {
            font-weight: 700;
            font-size: 1.2rem;
        }

        .player-hits {
            color: #ff0080;
            font-weight: 900;
            font-size: 1.4rem;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 15px #ff0080;
        }

        .activity-feed {
            max-height: 400px;
            overflow-y: auto;
        }

        .activity-feed::-webkit-scrollbar {
            width: 10px;
        }

        .activity-feed::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
        }

        .activity-feed::-webkit-scrollbar-thumb {
            background: rgba(0, 240, 255, 0.5);
            border-radius: 5px;
        }

        .activity-item {
            padding: 12px 18px;
            margin-bottom: 10px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            font-size: 1.05rem;
            border-left: 4px solid;
            transition: all 0.3s ease;
            animation: activitySlide 0.4s ease;
        }

        @keyframes activitySlide {
            from { opacity: 0; transform: translateX(-30px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .activity-item.damage {
            border-left-color: #ff0080;
        }

        .activity-item.heal {
            border-left-color: #00f0ff;
        }

        .message-banner {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 25px 50px;
            border-radius: 15px;
            font-size: 1.4rem;
            font-weight: 700;
            font-family: 'Orbitron', sans-serif;
            z-index: 1000;
            display: none;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(0, 240, 255, 0.5);
        }

        .message-banner.show {
            display: block;
            animation: bannerDrop 0.6s ease;
        }

        @keyframes bannerDrop {
            0% { opacity: 0; transform: translateX(-50%) translateY(-100px); }
            100% { opacity: 1; transform: translateX(-50%) translateY(0); }
        }

        .phase-transition {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            animation: transitionFade 0.5s ease;
        }

        .phase-transition.fadeOut {
            animation: transitionFadeOut 0.5s ease forwards;
        }

        @keyframes transitionFade {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes transitionFadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        .phase-transition-text {
            font-size: 5rem;
            font-weight: 900;
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
            letter-spacing: 8px;
            animation: transitionZoom 0.6s ease;
            text-shadow: 0 0 30px currentColor;
        }

        @keyframes transitionZoom {
            0% { transform: scale(0); opacity: 0; }
            60% { transform: scale(1.3); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }

        .victory-confetti {
            position: fixed;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            animation: confettiFall 3s linear forwards;
            z-index: 1999;
            box-shadow: 0 0 10px currentColor;
        }

        @keyframes confettiFall {
            to { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }

        .admin-controls {
            background: rgba(0, 0, 0, 0.5);
            padding: 25px;
            border-radius: 20px;
            border: 2px solid rgba(94, 82, 237, 0.5);
        }

        .admin-controls h3 {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.6rem;
            font-family: 'Orbitron', sans-serif;
            color: #5e52ed;
            text-shadow: 0 0 20px #5e52ed;
        }

        .admin-auth input {
            width: 100%;
            padding: 12px;
            border: 2px solid rgba(94, 82, 237, 0.5);
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            font-size: 1rem;
            margin-bottom: 15px;
        }

        .admin-auth input:focus {
            outline: none;
            border-color: #5e52ed;
            box-shadow: 0 0 20px rgba(94, 82, 237, 0.5);
        }

        .admin-btn {
            width: 100%;
            padding: 15px;
            margin-bottom: 12px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, #5e52ed, #3742fa);
            color: white;
            font-weight: 700;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            transition: all 0.4s ease;
            text-transform: uppercase;
        }

        .admin-btn:hover {
            background: linear-gradient(135deg, #3742fa, #5e52ed);
            transform: translateY(-3px);
        }

        .admin-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .boss-status {
            text-align: center;
            font-size: 2rem;
            margin-bottom: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
        }

        .status-indicator {
            display: inline-block;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            box-shadow: 0 0 15px currentColor;
            animation: statusPulse 2s ease-in-out infinite;
        }

        @keyframes statusPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        .status-connected {
            background: #00f0ff;
        }

        .status-disconnected {
            background: #ff0080;
        }

        @media (max-width: 1200px) {
            .container { flex-direction: column; }
            .right-panel { width: 100%; }
        }
    </style>
</head>
<body>
    <div class="particles" id="particles"></div>
    <div class="message-banner" id="messageBanner"></div>
    
    <div class="container">
        <div class="corner-logo">
            <img src="apex_logo.png" alt="Logo" class="small-logo">
        </div>
        <div class="game-title">APEX GAUNTLET</div>
        
        <div class="left-panel">
            <div class="card">
                <div class="game-phase" id="gamePhase">IDLE</div>
                <div class="timer" id="timer"></div>
            </div>
            
            <div class="card boss-container">
                <div class="boss-status" id="bossStatus">
                    <span class="status-indicator status-disconnected" id="connectionStatus"></span>
                    Waiting for game to start...
                </div>
                
                <div class="boss-image-container">
                    <img id="bossImage" class="boss-image" src="the_rock.png" alt="Boss">
                </div>
                
                <div class="boss-hp">
                    <div class="hp-bar">
                        <div class="hp-fill" id="hpFill" style="width: 100%"></div>
                        <div class="hp-text" id="hpText">30 / 30</div>
                    </div>
                </div>
                
                <div class="betting-section" id="bettingSection" style="display: none;">
                    <h3>‚ö° PLACE YOUR BETS ‚ö°</h3>
                    <div class="betting-pools">
                        <div class="betting-pool death">
                            <div class="pool-title">üíÄ BOSS DIES</div>
                            <div class="pool-amount" id="deathPool">0 SOL</div>
                            <div class="pool-bets" id="deathBets">0 bets</div>
                        </div>
                        <div class="betting-pool survival">
                            <div class="pool-title">üõ°Ô∏è BOSS SURVIVES</div>
                            <div class="pool-amount" id="survivalPool">0 SOL</div>
                            <div class="pool-bets" id="survivalBets">0 bets</div>
                        </div>
                    </div>
                    
                    <button class="connect-wallet" id="connectWallet">CONNECT PHANTOM</button>
                    <div class="wallet-address" id="walletAddress" style="display: none;"></div>
                    
                    <div class="bet-form" id="betForm">
                        <div class="bet-buttons">
                            <button class="bet-btn death" id="betDeath">BET 0.1 SOL - DEATH</button>
                            <button class="bet-btn survival" id="betSurvival">BET 0.1 SOL - SURVIVAL</button>
                        </div>
                    </div>
                    
                    <button class="admin-btn" id="claimPayoutBtn" style="display: none;">CLAIM WINNINGS</button>
                </div>
            </div>
        </div>
        
        <div class="right-panel">
            <div class="card leaderboard">
                <h3>üèÜ TOP DAMAGE DEALERS</h3>
                <div id="topPlayers"></div>
                <div style="margin-top: 20px; text-align: center; font-size: 1.1rem;">
                    <div style="margin-bottom: 8px;">Last Hit: <span id="lastHitter" style="color: #ff0080; font-weight: 700;">None</span></div>
                    <div>Total Hits: <span id="totalHits" style="color: #00f0ff; font-weight: 700;">0</span></div>
                </div>
            </div>
            
            <div class="card activity-feed">
                <h3>üì° LIVE ACTIVITY</h3>
                <div id="activityList"></div>
            </div>
            
            <div class="card admin-controls">
                <h3>üîê ADMIN PANEL</h3>
                <div class="admin-auth">
                    <input type="password" id="adminKey" placeholder="Admin key required" autocomplete="off" />
                </div>
                <button class="admin-btn" id="startBetting">START BETTING</button>
                <button class="admin-btn" id="resetGame">RESET GAME</button>
                <div id="adminError" style="color: #ff0080; margin-top: 12px; text-align: center; display: none; font-weight: 700;"></div>
            </div>
        </div>
    </div>

    <script>
        // Create particles
        function createParticles() {
            const container = document.getElementById('particles');
            for (let i = 0; i < 80; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.top = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 20 + 's';
                container.appendChild(particle);
            }
        }
        createParticles();

        // Solana configuration
        const PROGRAM_ID = new solanaWeb3.PublicKey('FtQbMDA7w8a9icfbMkuTxxQ695Wp9e6RQFSGVjmYQgz3');
        const DEVNET_RPC = 'https://api.devnet.solana.com';
        const connection = new solanaWeb3.Connection(DEVNET_RPC, 'confirmed');
        
        // Socket connection
        const socket = io();
        
        // Game state
        let gameState = {
            gamePhase: 'idle',
            bossHP: 30,
            maxHP: 30,
            totalDeathBets: 0,
            totalSurvivalBets: 0,
            connected: false,
            currentRoundId: 0,
            bossDefeated: false
        };
        
        // Wallet state
        let wallet = {
            connected: false,
            address: null,
            phantom: null,
            publicKey: null
        };
        
        let userBet = null;
        
        // DOM elements
        const el = {
            gamePhase: document.getElementById('gamePhase'),
            timer: document.getElementById('timer'),
            bossStatus: document.getElementById('bossStatus'),
            connectionStatus: document.getElementById('connectionStatus'),
            hpFill: document.getElementById('hpFill'),
            hpText: document.getElementById('hpText'),
            bossImage: document.getElementById('bossImage'),
            bettingSection: document.getElementById('bettingSection'),
            deathPool: document.getElementById('deathPool'),
            survivalPool: document.getElementById('survivalPool'),
            deathBets: document.getElementById('deathBets'),
            survivalBets: document.getElementById('survivalBets'),
            connectWallet: document.getElementById('connectWallet'),
            walletAddress: document.getElementById('walletAddress'),
            betForm: document.getElementById('betForm'),
            usernameInput: document.getElementById('usernameInput'),
            usernameInput: document.getElementById('usernameInput'),
            betDeath: document.getElementById('betDeath'),
            betSurvival: document.getElementById('betSurvival'),
            claimPayoutBtn: document.getElementById('claimPayoutBtn'),
            topPlayers: document.getElementById('topPlayers'),
            lastHitter: document.getElementById('lastHitter'),
            totalHits: document.getElementById('totalHits'),
            activityList: document.getElementById('activityList'),
            messageBanner: document.getElementById('messageBanner'),
            startBetting: document.getElementById('startBetting'),
            resetGame: document.getElementById('resetGame'),
            adminKey: document.getElementById('adminKey'),
            adminError: document.getElementById('adminError')
        };
        
        // Utility functions
        function showMessage(msg) {
            el.messageBanner.textContent = msg;
            el.messageBanner.classList.add('show');
            setTimeout(() => el.messageBanner.classList.remove('show'), 5000);
        }
        
        function showPhaseTransition(text, duration = 2000) {
            const colors = { 'BETTING': '#ffd700', 'FIGHT': '#ff0080', 'DEFEATED': '#00f0ff', 'SURVIVED': '#2ed573' };
            const color = Object.keys(colors).find(k => text.includes(k)) || '#00f0ff';
            
            const overlay = document.createElement('div');
            overlay.className = 'phase-transition';
            overlay.innerHTML = `<div class="phase-transition-text" style="color: ${colors[color] || color}">${text}</div>`;
            document.body.appendChild(overlay);
            
            setTimeout(() => {
                overlay.classList.add('fadeOut');
                setTimeout(() => overlay.remove(), 500);
            }, duration);
        }
        
        function createConfetti() {
            const colors = ['#ffd700', '#ff0080', '#00f0ff', '#2ed573', '#5e52ed'];
            for (let i = 0; i < 100; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'victory-confetti';
                confetti.style.left = Math.random() * 100 + '%';
                confetti.style.top = '-10%';
                confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.animationDelay = Math.random() * 0.5 + 's';
                document.body.appendChild(confetti);
                setTimeout(() => confetti.remove(), 3000);
            }
        }
        
        function showHitEffect(damage) {
            const effect = document.createElement('div');
            effect.className = 'hit-effect';
            effect.textContent = `-${damage}`;
            effect.style.left = '50%';
            effect.style.top = '50%';
            document.querySelector('.boss-image-container').appendChild(effect);
            setTimeout(() => effect.remove(), 800);
        }
        
        function showHealEffect(heal) {
            const effect = document.createElement('div');
            effect.className = 'heal-effect';
            effect.textContent = `+${heal}`;
            effect.style.left = '50%';
            effect.style.top = '50%';
            document.querySelector('.boss-image-container').appendChild(effect);
            setTimeout(() => effect.remove(), 800);
        }
        
        function updateDisplay() {
            el.gamePhase.textContent = gameState.gamePhase.toUpperCase();
            el.gamePhase.className = `game-phase phase-${gameState.gamePhase}`;
            
            el.connectionStatus.className = `status-indicator ${gameState.connected ? 'status-connected' : 'status-disconnected'}`;
            
            const statusTexts = {
                'idle': 'Waiting for game to start...',
                'betting': '‚ö° Betting phase active!',
                'fighting': '‚öîÔ∏è Apex Gauntlet in progress!',
                'ended': gameState.bossDefeated ? 'üíÄ Boss defeated!' : 'üõ°Ô∏è Boss survived!'
            };
            el.bossStatus.innerHTML = `<span class="status-indicator ${gameState.connected ? 'status-connected' : 'status-disconnected'}"></span>${statusTexts[gameState.gamePhase] || ''}`;
            
            const hpPercentage = (gameState.bossHP / gameState.maxHP) * 100;
            el.hpFill.style.width = `${hpPercentage}%`;
            el.hpText.textContent = `${gameState.bossHP} / ${gameState.maxHP}`;
            
            if (gameState.gamePhase === 'betting') {
                el.bettingSection.style.display = 'block';
                if (wallet.connected && !userBet) {
                    el.betForm.classList.add('active');
                }
            } else {
                el.bettingSection.style.display = 'none';
            }
            
            el.deathPool.textContent = `${(gameState.totalDeathBets || 0).toFixed(2)} SOL`;
            el.survivalPool.textContent = `${(gameState.totalSurvivalBets || 0).toFixed(2)} SOL`;
            el.deathBets.textContent = `${gameState.totalDeathBets || 0} bets`;
            el.survivalBets.textContent = `${gameState.totalSurvivalBets || 0} bets`;
            
            el.lastHitter.textContent = gameState.lastHitter || 'None';
            el.totalHits.textContent = gameState.totalHits || '0';
        }
        
        function updateLeaderboard(topPlayers) {
            if (!topPlayers) return;
            el.topPlayers.innerHTML = '';
            topPlayers.forEach((player, index) => {
                const div = document.createElement('div');
                div.className = 'top-player';
                const medals = ['ü•á', 'ü•à', 'ü•â'];
                div.innerHTML = `
                    <span class="player-name">${medals[index] || `#${index + 1}`} ${player.username}</span>
                    <span class="player-hits">${player.hits} üí•</span>
                `;
                el.topPlayers.appendChild(div);
            });
        }
        
        function addActivityItem(activity) {
            const item = document.createElement('div');
            item.className = `activity-item ${activity.delta < 0 ? 'damage' : 'heal'}`;
            const icon = activity.delta < 0 ? '‚öîÔ∏è' : 'üíö';
            const action = activity.delta < 0 ? 'dealt' : 'healed';
            item.textContent = `${icon} ${activity.username} ${action} ${Math.abs(activity.delta)} damage`;
            
            el.activityList.insertBefore(item, el.activityList.firstChild);
            while (el.activityList.children.length > 25) {
                el.activityList.removeChild(el.activityList.lastChild);
            }
        }
        
        // Socket events
        socket.on('state', (data) => {
            gameState = { ...gameState, ...data };
            updateDisplay();
            if (gameState.top) updateLeaderboard(gameState.top);
        });
        
        socket.on('update', (data) => {
            if (data.bossHP !== undefined && data.bossHP > gameState.bossHP) {
                showHealEffect(data.bossHP - gameState.bossHP);
                el.bossImage.classList.add('healed');
                setTimeout(() => el.bossImage.classList.remove('healed'), 600);
            }
            if (data.bossHP !== undefined && data.bossHP < gameState.bossHP) {
                showHitEffect(gameState.bossHP - data.bossHP);
                el.bossImage.classList.add('damaged');
                setTimeout(() => el.bossImage.classList.remove('damaged'), 300);
            }
            
            gameState = { ...gameState, ...data };
            updateDisplay();
            if (gameState.top) updateLeaderboard(gameState.top);
            if (data.latest) addActivityItem(data.latest);
        });
        
        socket.on('timer_update', (data) => {
            const seconds = Math.ceil(data.timeRemaining / 1000);
            const minutes = Math.floor(seconds / 60);
            const secs = seconds % 60;
            const timeStr = `${minutes}:${secs.toString().padStart(2, '0')}`;
            
            if (data.phase === 'betting') {
                el.timer.textContent = `‚è±Ô∏è Betting ends in: ${timeStr}`;
            } else if (data.phase === 'fighting') {
                el.timer.textContent = `‚öîÔ∏è Fight ends in: ${timeStr}`;
            }
            
            if (seconds <= 10) {
                el.timer.classList.add('warning');
            } else {
                el.timer.classList.remove('warning');
            }
        });
        
        socket.on('phase_change', (data) => {
            gameState = { ...gameState, ...data };
            
            if (data.currentRoundId && userBet && userBet.roundId !== data.currentRoundId) {
                userBet = null;
                el.betDeath.disabled = false;
                el.betSurvival.disabled = false;
                el.usernameInput.value = '';
            }
            
            if (data.gamePhase === 'betting') {
                showPhaseTransition('‚ö° BETTING PHASE START! ‚ö°');
            } else if (data.gamePhase === 'fighting') {
                showPhaseTransition('‚öîÔ∏è FIGHT BEGINS! ‚öîÔ∏è');
            }
            
            updateDisplay();
            if (data.message) showMessage(data.message);
            
            if (data.gamePhase === 'betting' && wallet.connected) {
                setTimeout(() => loadBettingData(), 500);
            }
        });
        
        socket.on('fight_ended', (data) => {
            gameState = { ...gameState, ...data };
            
            if (data.bossDefeated) {
                el.bossImage.classList.add('defeated');
                createConfetti();
                showPhaseTransition('üíÄ BOSS DEFEATED! üíÄ', 3000);
            } else {
                showPhaseTransition('üõ°Ô∏è BOSS SURVIVED! üõ°Ô∏è', 3000);
            }
            
            updateDisplay();
            if (data.message) showMessage(data.message);
            
            if (userBet && wallet.connected) {
                checkClaimEligibility();
            }
        });
        
        socket.on('betting_update', (data) => {
            gameState = { ...gameState, ...data };
            updateDisplay();
        });
        
        socket.on('game_reset', (data) => {
            gameState = { ...gameState, ...data };
            userBet = null;
            el.claimPayoutBtn.style.display = 'none';
            el.bossImage.classList.remove('defeated');
            updateDisplay();
            if (data.message) showMessage(data.message);
        });
        
        socket.on('connection_status', (data) => {
            gameState.connected = data.connected;
            updateDisplay();
        });
        
        socket.on('admin:error', (data) => {
            el.adminError.textContent = data.message;
            el.adminError.style.display = 'block';
            setTimeout(() => el.adminError.style.display = 'none', 3000);
        });
        
        // Wallet connection
        el.connectWallet.addEventListener('click', async () => {
            if (!wallet.connected) await connectWallet();
        });
        
        async function connectWallet() {
            try {
                if (window.solana && window.solana.isPhantom) {
                    const response = await window.solana.connect();
                    wallet.connected = true;
                    wallet.address = response.publicKey.toString();
                    wallet.phantom = window.solana;
                    wallet.publicKey = response.publicKey;
                    
                    el.connectWallet.textContent = '‚úÖ WALLET CONNECTED';
                    el.connectWallet.classList.add('wallet-connected');
                    el.walletAddress.textContent = `${wallet.address.substring(0, 8)}...${wallet.address.substring(wallet.address.length - 8)}`;
                    el.walletAddress.style.display = 'block';
                    
                    if (gameState.gamePhase === 'betting') {
                        el.betForm.classList.add('active');
                        await loadBettingData();
                    }
                    
                    showMessage('‚úÖ Wallet connected successfully!');
                } else {
                    showMessage('‚ö†Ô∏è Phantom wallet not found. Please install Phantom.');
                    window.open('https://phantom.app/', '_blank');
                }
            } catch (error) {
                console.error('Error connecting wallet:', error);
                showMessage('‚ùå Error connecting wallet. Please try again.');
            }
        }
        
        // Auto-connect on load
        window.addEventListener('load', async () => {
            if (window.solana && window.solana.isPhantom) {
                try {
                    const response = await window.solana.connect({ onlyIfTrusted: true });
                    wallet.connected = true;
                    wallet.address = response.publicKey.toString();
                    wallet.phantom = window.solana;
                    wallet.publicKey = response.publicKey;
                    
                    el.connectWallet.textContent = '‚úÖ WALLET CONNECTED';
                    el.connectWallet.classList.add('wallet-connected');
                    el.walletAddress.textContent = `${wallet.address.substring(0, 8)}...${wallet.address.substring(wallet.address.length - 8)}`;
                    el.walletAddress.style.display = 'block';
                    
                    if (gameState.gamePhase === 'betting') {
                        await loadBettingData();
                    }
                } catch (err) {
                    console.log('Auto-connect not approved');
                }
            } else {
                el.connectWallet.textContent = 'INSTALL PHANTOM';
                el.connectWallet.onclick = () => window.open('https://phantom.app/', '_blank');
            }
        });
        
        async function loadBettingData() {
            if (!wallet.connected || !gameState.currentRoundId) return;
            
            try {
                const response = await fetch(`/api/bet-status/${wallet.address}/${gameState.currentRoundId}`);
                const data = await response.json();
                
                if (data.exists) {
                    userBet = {
                        roundId: gameState.currentRoundId,
                        amount: data.amount,
                        prediction: data.prediction,
                        username: data.username
                    };
                    el.betForm.classList.remove('active');
                    showMessage('‚ÑπÔ∏è You have already placed a bet for this round.');
                }
            } catch (error) {
                console.log('No existing bet found');
            }
        }
        
        // Betting
        el.betDeath.addEventListener('click', () => placeBet('death'));
        el.betSurvival.addEventListener('click', () => placeBet('survival'));
        
        async function placeBet(prediction) {
            // Generate username from wallet address
            const username = wallet.address ? `${wallet.address.substring(0, 4)}...${wallet.address.substring(wallet.address.length - 4)}` : 'Anonymous';
            const amount = 0.1;
            
            if (!wallet.connected) { 
                showMessage('‚ö†Ô∏è Connect wallet first'); 
                audioSystem.playErrorSound();
                return; 
            }
            if (userBet) { 
                showMessage('‚ÑπÔ∏è Already placed bet'); 
                return; 
            }
            
            el.betDeath.disabled = true;
            el.betSurvival.disabled = true;
            
            try {
                showMessage('‚è≥ Preparing transaction...');

                const response = await fetch('/api/place-bet', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        walletAddress: wallet.address, 
                        username, 
                        amount, 
                        prediction 
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Failed to prepare transaction');
                }
                
                const { transaction: base64Tx } = await response.json();
                const txBytes = Uint8Array.from(atob(base64Tx), c => c.charCodeAt(0));
                const transaction = solanaWeb3.Transaction.from(txBytes);
                
                showMessage('‚úçÔ∏è Sign transaction in your wallet...');
                const signed = await wallet.phantom.signTransaction(transaction);
                
                showMessage('üì° Sending transaction...');
                
                // Get recent blockhash to ensure uniqueness
                const { blockhash } = await connection.getLatestBlockhash('confirmed');
                transaction.recentBlockhash = blockhash;
                
                const signature = await connection.sendRawTransaction(signed.serialize(), {
                    skipPreflight: false,
                    preflightCommitment: 'confirmed',
                    maxRetries: 2
                });
                
                showMessage('‚è≥ Confirming transaction...');
                
                // Wait for confirmation with timeout
                const confirmation = await Promise.race([
                    connection.confirmTransaction({
                        signature: signature,
                        blockhash: blockhash,
                        lastValidBlockHeight: (await connection.getLatestBlockhash()).lastValidBlockHeight
                    }, 'confirmed'),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Transaction confirmation timeout')), 30000))
                ]);
                
                if (confirmation.value.err) {
                    throw new Error('Transaction failed: ' + JSON.stringify(confirmation.value.err));
                }
                
                userBet = { roundId: gameState.currentRoundId, amount, prediction, username, signature };
                el.betForm.classList.remove('active');
                showMessage(`‚úÖ Bet placed successfully! 0.1 SOL on ${prediction}`);
                
                // Notify server
                await fetch('/api/bet-notification', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        walletAddress: wallet.address, 
                        username, 
                        amount, 
                        prediction, 
                        signature 
                    })
                });
                
                audioSystem.playBetPlaced();
                setTimeout(() => audioSystem.playCoinDrop(), 200);
                
            } catch (error) {
                console.error('Bet error:', error);
                
                // Check if bet was actually placed despite error
                if (error.message.includes('already processed') || error.message.includes('BlockhashNotFound')) {
                    // Transaction might have succeeded, verify on chain
                    try {
                        const betStatus = await fetch(`/api/bet-status/${wallet.address}/${gameState.currentRoundId}`);
                        const data = await betStatus.json();
                        
                        if (data.exists) {
                            userBet = { 
                                roundId: gameState.currentRoundId, 
                                amount: data.amount, 
                                prediction: data.prediction, 
                                username: data.username 
                            };
                            el.betForm.classList.remove('active');
                            showMessage('‚úÖ Bet was placed successfully!');
                            audioSystem.playBetPlaced();
                            return;
                        }
                    } catch (checkError) {
                        console.log('Could not verify bet status');
                    }
                }
                
                showMessage('‚ùå Error: ' + error.message);
                audioSystem.playErrorSound();
                el.betDeath.disabled = false;
                el.betSurvival.disabled = false;
            }
        }
        
        async function checkClaimEligibility() {
            if (!userBet || !wallet.connected) return;
            
            const won = (userBet.prediction === 'death' && gameState.bossDefeated) ||
                       (userBet.prediction === 'survival' && !gameState.bossDefeated);
            
            if (won) {
                el.claimPayoutBtn.style.display = 'block';
            }
        }
        
        // Admin controls
        el.startBetting.addEventListener('click', () => {
            const adminKey = el.adminKey.value.trim();
            if (!adminKey) {
                el.adminError.textContent = '‚ö†Ô∏è Please enter admin key';
                el.adminError.style.display = 'block';
                setTimeout(() => el.adminError.style.display = 'none', 3000);
                return;
            }
            socket.emit('admin:start_betting', { 
                adminKey: adminKey,
                walletAddress: wallet.address
            });
        });
        
        el.resetGame.addEventListener('click', () => {
            const adminKey = el.adminKey.value.trim();
            if (!adminKey) {
                el.adminError.textContent = '‚ö†Ô∏è Please enter admin key';
                el.adminError.style.display = 'block';
                setTimeout(() => el.adminError.style.display = 'none', 3000);
                return;
            }
            socket.emit('admin:reset', { 
                adminKey: adminKey,
                walletAddress: wallet.address
            });
        });
        
        // Initialize
        updateDisplay();
        setTimeout(() => {
            showMessage('üéÆ Welcome to Apex Gauntlet! Connect your wallet to start betting.');
        }, 1000);
        
        // ============================================
        // AUDIO SYSTEM WITH ENGAGING SOUNDTRACKS
        // ============================================
        
        const audioSystem = {
            context: null,
            masterVolume: 0.5,
            sounds: {},
            backgroundMusic: null,
            
            init() {
                // Create audio context on first user interaction
                document.addEventListener('click', () => {
                    if (!this.context) {
                        this.context = new (window.AudioContext || window.webkitAudioContext)();
                        console.log('Audio system initialized');
                    }
                }, { once: true });
            },
            
            // Create synthetic sounds using Web Audio API
            createTone(frequency, duration, type = 'sine', volume = 0.3) {
                if (!this.context) return;
                
                const oscillator = this.context.createOscillator();
                const gainNode = this.context.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.context.destination);
                
                oscillator.type = type;
                oscillator.frequency.setValueAtTime(frequency, this.context.currentTime);
                
                gainNode.gain.setValueAtTime(volume * this.masterVolume, this.context.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + duration);
                
                oscillator.start(this.context.currentTime);
                oscillator.stop(this.context.currentTime + duration);
            },
            
            // Boss hit sound - aggressive impact
            playBossHit() {
                if (!this.context) return;
                
                // Low punch sound
                this.createTone(80, 0.15, 'sawtooth', 0.4);
                setTimeout(() => this.createTone(60, 0.1, 'square', 0.3), 50);
                
                // High impact crack
                setTimeout(() => {
                    this.createTone(1200, 0.08, 'square', 0.25);
                    this.createTone(800, 0.1, 'sawtooth', 0.2);
                }, 30);
                
                // Rumble
                setTimeout(() => this.createTone(40, 0.2, 'triangle', 0.15), 100);
            },
            
            // Boss heal sound - mystical recovery
            playBossHeal() {
                if (!this.context) return;
                
                // Ascending magical tones
                const notes = [262, 330, 392, 523, 659]; // C major arpeggio
                notes.forEach((freq, i) => {
                    setTimeout(() => {
                        this.createTone(freq, 0.3, 'sine', 0.2);
                        this.createTone(freq * 2, 0.25, 'sine', 0.1); // Harmonic
                    }, i * 80);
                });
                
                // Shimmer effect
                setTimeout(() => {
                    this.createTone(1047, 0.5, 'sine', 0.15);
                    this.createTone(1319, 0.5, 'sine', 0.12);
                }, 300);
            },
            
            // Betting phase start - exciting buildup
            playBettingStart() {
                if (!this.context) return;
                
                // Rising tension
                const frequencies = [220, 277, 330, 440];
                frequencies.forEach((freq, i) => {
                    setTimeout(() => {
                        this.createTone(freq, 0.2, 'square', 0.25);
                        this.createTone(freq * 1.5, 0.15, 'sine', 0.15);
                    }, i * 100);
                });
                
                // Climax chord
                setTimeout(() => {
                    this.createTone(440, 0.5, 'sawtooth', 0.3);
                    this.createTone(554, 0.5, 'sawtooth', 0.25);
                    this.createTone(659, 0.5, 'sawtooth', 0.2);
                }, 400);
            },
            
            // Fight start - epic battle horn
            playFightStart() {
                if (!this.context) return;
                
                // War horn
                this.createTone(165, 0.4, 'sawtooth', 0.35);
                setTimeout(() => this.createTone(220, 0.4, 'sawtooth', 0.35), 100);
                setTimeout(() => this.createTone(277, 0.6, 'sawtooth', 0.4), 200);
                
                // Drums
                setTimeout(() => {
                    for (let i = 0; i < 4; i++) {
                        setTimeout(() => {
                            this.createTone(80, 0.1, 'square', 0.4);
                            this.createTone(60, 0.12, 'triangle', 0.3);
                        }, i * 150);
                    }
                }, 300);
            },
            
            // Boss defeated - victory fanfare
            playBossDefeated() {
                if (!this.context) return;
                
                // Victory melody
                const victoryNotes = [
                    { freq: 523, duration: 0.15 }, // C
                    { freq: 659, duration: 0.15 }, // E
                    { freq: 784, duration: 0.15 }, // G
                    { freq: 1047, duration: 0.4 }  // High C
                ];
                
                victoryNotes.forEach((note, i) => {
                    setTimeout(() => {
                        this.createTone(note.freq, note.duration, 'triangle', 0.3);
                        this.createTone(note.freq * 2, note.duration, 'sine', 0.15);
                    }, i * 180);
                });
                
                // Triumphant chord at the end
                setTimeout(() => {
                    this.createTone(523, 0.8, 'sine', 0.25);
                    this.createTone(659, 0.8, 'sine', 0.2);
                    this.createTone(784, 0.8, 'sine', 0.18);
                    this.createTone(1047, 0.8, 'sine', 0.15);
                }, 720);
            },
            
            // Boss survived - somber defeat
            playBossSurvived() {
                if (!this.context) return;
                
                // Descending sad melody
                const defeatNotes = [
                    { freq: 440, duration: 0.3 },  // A
                    { freq: 392, duration: 0.3 },  // G
                    { freq: 349, duration: 0.3 },  // F
                    { freq: 330, duration: 0.6 }   // E
                ];
                
                defeatNotes.forEach((note, i) => {
                    setTimeout(() => {
                        this.createTone(note.freq, note.duration, 'sine', 0.25);
                        this.createTone(note.freq - 20, note.duration, 'sine', 0.15);
                    }, i * 350);
                });
                
                // Final low drone
                setTimeout(() => {
                    this.createTone(110, 1.0, 'triangle', 0.2);
                }, 1400);
            },
            
            // Wallet connected - success chime
            playWalletConnected() {
                if (!this.context) return;
                
                this.createTone(659, 0.15, 'sine', 0.25);
                setTimeout(() => this.createTone(784, 0.15, 'sine', 0.25), 100);
                setTimeout(() => this.createTone(1047, 0.3, 'sine', 0.3), 200);
            },
            
            // Bet placed - confirmation beep
            playBetPlaced() {
                if (!this.context) return;
                
                this.createTone(880, 0.1, 'square', 0.25);
                setTimeout(() => this.createTone(1100, 0.15, 'square', 0.25), 80);
            },
            
            // Timer warning - urgent beeps
            playTimerWarning() {
                if (!this.context) return;
                
                this.createTone(800, 0.08, 'square', 0.2);
                setTimeout(() => this.createTone(800, 0.08, 'square', 0.2), 150);
            },
            
            // Background ambient music for betting phase
            playBettingMusic() {
                if (!this.context || this.backgroundMusic) return;
                
                const playAmbientLoop = () => {
                    if (gameState.gamePhase !== 'betting') return;
                    
                    // Soft ambient pad
                    const chordNotes = [220, 277, 330, 440];
                    chordNotes.forEach((freq, i) => {
                        setTimeout(() => {
                            this.createTone(freq, 4.0, 'sine', 0.08);
                        }, i * 50);
                    });
                    
                    // Melodic element
                    setTimeout(() => {
                        const melody = [440, 494, 523, 494, 440, 392];
                        melody.forEach((freq, i) => {
                            setTimeout(() => {
                                this.createTone(freq, 0.4, 'triangle', 0.1);
                            }, i * 600);
                        });
                    }, 1000);
                    
                    this.backgroundMusic = setTimeout(playAmbientLoop, 8000);
                };
                
                playAmbientLoop();
            },
            
            // Background battle music for fighting phase
            playFightingMusic() {
                if (!this.context || this.backgroundMusic) return;
                
                const playBattleLoop = () => {
                    if (gameState.gamePhase !== 'fighting') return;
                    
                    // Intense rhythm
                    const beats = [0, 250, 500, 750];
                    beats.forEach(delay => {
                        setTimeout(() => {
                            this.createTone(110, 0.15, 'square', 0.15);
                            this.createTone(55, 0.2, 'triangle', 0.12);
                        }, delay);
                    });
                    
                    // Aggressive melody
                    setTimeout(() => {
                        const battleMelody = [330, 370, 440, 370, 330, 294];
                        battleMelody.forEach((freq, i) => {
                            setTimeout(() => {
                                this.createTone(freq, 0.2, 'sawtooth', 0.12);
                            }, i * 300);
                        });
                    }, 1000);
                    
                    this.backgroundMusic = setTimeout(playBattleLoop, 3000);
                };
                
                playBattleLoop();
            },
            
            stopBackgroundMusic() {
                if (this.backgroundMusic) {
                    clearTimeout(this.backgroundMusic);
                    this.backgroundMusic = null;
                }
            }
        };
        
        // Initialize audio system
        audioSystem.init();
        
        // Add audio to existing game events
        const originalShowHitEffect = showHitEffect;
        showHitEffect = function(damage) {
            originalShowHitEffect(damage);
            audioSystem.playBossHit();
        };
        
        const originalShowHealEffect = showHealEffect;
        showHealEffect = function(heal) {
            originalShowHealEffect(heal);
            audioSystem.playBossHeal();
        };
        
        // Enhance socket event handlers with audio
        const originalPhaseChangeHandler = socket._callbacks['$phase_change'] || [];
        socket.on('phase_change', (data) => {
            if (data.gamePhase === 'betting') {
                audioSystem.stopBackgroundMusic();
                audioSystem.playBettingStart();
                setTimeout(() => audioSystem.playBettingMusic(), 1000);
            } else if (data.gamePhase === 'fighting') {
                audioSystem.stopBackgroundMusic();
                audioSystem.playFightStart();
                setTimeout(() => audioSystem.playFightingMusic(), 1000);
            }
        });
        
        const originalFightEndedHandler = socket._callbacks['$fight_ended'] || [];
        socket.on('fight_ended', (data) => {
            audioSystem.stopBackgroundMusic();
            if (data.bossDefeated) {
                audioSystem.playBossDefeated();
            } else {
                audioSystem.playBossSurvived();
            }
        });
        
        // Add audio to wallet connection
        const originalConnectWallet = connectWallet;
        connectWallet = async function() {
            await originalConnectWallet();
            if (wallet.connected) {
                audioSystem.playWalletConnected();
            }
        };
        
        // Add audio to bet placement
        const originalPlaceBet = placeBet;
        placeBet = async function(prediction) {
            await originalPlaceBet(prediction);
            if (userBet) {
                audioSystem.playBetPlaced();
            }
        };
        
        // Add timer warning sound
        let lastWarningTime = 0;
        socket.on('timer_update', (data) => {
            const seconds = Math.ceil(data.timeRemaining / 1000);
            
            if (seconds <= 10 && seconds !== lastWarningTime) {
                audioSystem.playTimerWarning();
                lastWarningTime = seconds;
            }
            
            if (seconds > 10) {
                lastWarningTime = 0;
            }
        });
        
                    // Volume control (optional - add UI for this)
        window.setGameVolume = function(volume) {
            audioSystem.masterVolume = Math.max(0, Math.min(1, volume));
        };
        
        // ============================================
        // ADDITIONAL AUDIO ENHANCEMENTS
        // ============================================
        
        // Add more engaging sounds
        audioSystem.playGameReset = function() {
            if (!this.context) return;
            
            // Whoosh reset sound
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    this.createTone(2000 - (i * 150), 0.05, 'sine', 0.15);
                }, i * 30);
            }
            
            // Final reset tone
            setTimeout(() => {
                this.createTone(220, 0.3, 'triangle', 0.25);
            }, 350);
        };
        
        audioSystem.playCountdownTick = function() {
            if (!this.context) return;
            this.createTone(600, 0.05, 'square', 0.18);
        };
        
        audioSystem.playBettingClosed = function() {
            if (!this.context) return;
            
            // Door closing sound
            this.createTone(300, 0.2, 'sawtooth', 0.3);
            setTimeout(() => this.createTone(200, 0.3, 'sawtooth', 0.35), 100);
            setTimeout(() => this.createTone(150, 0.4, 'square', 0.25), 200);
        };
        
        audioSystem.playBossRoar = function() {
            if (!this.context) return;
            
            // Deep menacing roar
            this.createTone(80, 0.5, 'sawtooth', 0.35);
            setTimeout(() => this.createTone(120, 0.4, 'square', 0.3), 100);
            setTimeout(() => this.createTone(90, 0.6, 'sawtooth', 0.32), 200);
            
            // Distorted overtones
            setTimeout(() => {
                this.createTone(200, 0.3, 'square', 0.2);
                this.createTone(250, 0.25, 'sawtooth', 0.18);
            }, 150);
        };
        
        audioSystem.playComboHit = function(comboCount) {
            if (!this.context) return;
            
            // Escalating hit sounds based on combo
            const baseFreq = 400 + (comboCount * 100);
            this.createTone(baseFreq, 0.1, 'square', 0.3);
            setTimeout(() => this.createTone(baseFreq * 1.5, 0.08, 'sine', 0.25), 50);
            
            if (comboCount >= 5) {
                // Special effect for high combos
                setTimeout(() => {
                    this.createTone(1200, 0.2, 'sine', 0.2);
                    this.createTone(1600, 0.15, 'sine', 0.15);
                }, 100);
            }
        };
        
        audioSystem.playCoinDrop = function() {
            if (!this.context) return;
            
            // Bouncing coin sound
            const bounces = [880, 660, 550, 440, 400];
            bounces.forEach((freq, i) => {
                setTimeout(() => {
                    this.createTone(freq, 0.1, 'sine', 0.2 - (i * 0.03));
                }, i * 80);
            });
        };
        
        audioSystem.playClaimWinnings = function() {
            if (!this.context) return;
            
            // Cash register sound
            this.createTone(1047, 0.1, 'square', 0.25);
            setTimeout(() => this.createTone(1319, 0.1, 'square', 0.25), 80);
            setTimeout(() => this.createTone(1568, 0.2, 'sine', 0.3), 160);
            
            // Coins falling
            setTimeout(() => {
                for (let i = 0; i < 8; i++) {
                    setTimeout(() => {
                        this.createTone(800 + Math.random() * 400, 0.05, 'sine', 0.15);
                    }, i * 40);
                }
            }, 400);
        };
        
        audioSystem.playBossLowHealth = function() {
            if (!this.context) return;
            
            // Urgent warning
            this.createTone(880, 0.1, 'square', 0.25);
            setTimeout(() => this.createTone(740, 0.1, 'square', 0.25), 120);
        };
        
        audioSystem.playPhaseTransition = function() {
            if (!this.context) return;
            
            // Dramatic transition sweep
            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    this.createTone(200 + (i * 50), 0.08, 'sine', 0.15);
                }, i * 25);
            }
        };
        
        audioSystem.playErrorSound = function() {
            if (!this.context) return;
            
            // Error buzz
            this.createTone(200, 0.15, 'square', 0.3);
            setTimeout(() => this.createTone(180, 0.2, 'square', 0.3), 100);
        };
        
        audioSystem.playSuccessChime = function() {
            if (!this.context) return;
            
            // Pleasant success melody
            const notes = [523, 659, 784];
            notes.forEach((freq, i) => {
                setTimeout(() => {
                    this.createTone(freq, 0.15, 'sine', 0.22);
                }, i * 100);
            });
        };
        
        // Enhanced event integration
        socket.on('game_reset', (data) => {
            audioSystem.playGameReset();
        });
        
        // Boss low health warning (when HP < 30%)
        let lastHealthWarning = false;
        socket.on('update', (data) => {
            if (data.bossHP !== undefined) {
                const healthPercent = (data.bossHP / gameState.maxHP) * 100;
                
                if (healthPercent < 30 && healthPercent > 0 && !lastHealthWarning) {
                    audioSystem.playBossLowHealth();
                    lastHealthWarning = true;
                }
                
                if (healthPercent >= 30) {
                    lastHealthWarning = false;
                }
            }
        });
        
        // Phase transition sound
        socket.on('phase_change', (data) => {
            audioSystem.playPhaseTransition();
            
            if (data.gamePhase === 'fighting') {
                // Boss roars when fight starts
                setTimeout(() => audioSystem.playBossRoar(), 500);
            }
        });
        
        // Countdown ticks in last 5 seconds
        socket.on('timer_update', (data) => {
            const seconds = Math.ceil(data.timeRemaining / 1000);
            
            if (seconds <= 5 && seconds > 0) {
                // Tick on each second
                const currentSecond = Math.floor(Date.now() / 1000);
                if (window.lastTickSecond !== currentSecond) {
                    audioSystem.playCountdownTick();
                    window.lastTickSecond = currentSecond;
                }
            }
            
            // Betting closed sound
            if (data.phase === 'betting' && seconds === 0) {
                setTimeout(() => audioSystem.playBettingClosed(), 100);
            }
        });
        
        // Coin drop on bet placement
        const originalPlaceBetEnhanced = placeBet;
        placeBet = async function(prediction) {
            try {
                await originalPlaceBetEnhanced(prediction);
                if (userBet) {
                    audioSystem.playBetPlaced();
                    setTimeout(() => audioSystem.playCoinDrop(), 200);
                }
            } catch (error) {
                audioSystem.playErrorSound();
                throw error;
            }
        };
        
        // Claim winnings sound
        el.claimPayoutBtn.addEventListener('click', () => {
            audioSystem.playClaimWinnings();
        });
        
        // Success/error sounds for admin actions
        socket.on('admin:error', (data) => {
            audioSystem.playErrorSound();
        });
        
        const originalStartBettingClick = el.startBetting.onclick;
        el.startBetting.addEventListener('click', () => {
            if (el.adminKey.value.trim()) {
                audioSystem.playSuccessChime();
            }
        });
        
        // Combo hit tracking (optional - tracks consecutive hits)
        let comboCount = 0;
        let comboTimer = null;
        
        socket.on('update', (data) => {
            if (data.bossHP !== undefined && data.bossHP < gameState.bossHP) {
                comboCount++;
                
                if (comboTimer) clearTimeout(comboTimer);
                
                // Play combo sound
                if (comboCount > 1) {
                    audioSystem.playComboHit(comboCount);
                }
                
                // Reset combo after 3 seconds of no hits
                comboTimer = setTimeout(() => {
                    comboCount = 0;
                }, 3000);
            }
        });
        
        // Victory celebration enhancement
        socket.on('fight_ended', (data) => {
            if (data.bossDefeated) {
                // Extra celebratory sounds
                setTimeout(() => audioSystem.playSuccessChime(), 1000);
                setTimeout(() => audioSystem.playClaimWinnings(), 1500);
            }
        });
        
        // Dramatic sound when boss is first shown
        let bossIntroPlayed = false;
        socket.on('phase_change', (data) => {
            if (data.gamePhase === 'fighting' && !bossIntroPlayed) {
                setTimeout(() => {
                    audioSystem.playBossRoar();
                    bossIntroPlayed = true;
                }, 1000);
            }
        });
    </script>
</body>
</html>